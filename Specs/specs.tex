\documentclass{article}
\usepackage{fullpage}
\usepackage{epsfig}
\usepackage{color}
\usepackage{mathtools}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{amsmath}
\addtolength{\parskip}{-1mm}
\usepackage{graphics}
\newenvironment{changemargin}[2]{%
  \begin{list}{}{%
    \setlength{\topsep}{0pt}%
    \setlength{\leftmargin}{#1}%
    \setlength{\rightmargin}{#2}%
    \setlength{\listparindent}{\parindent}%
    \setlength{\itemindent}{\parindent}%
    \setlength{\parsep}{\parskip}%
  }%
  \item[]}{\end{list}}

\title{ CS335[Introduction to Compiler Design]\\Specifications for designing the Oberon Compiler\vspace{0.25 in}}
\author{{\Large{\bf Group Number : 14}}\\Mohd. Dawood \hspace{0.5cm} Mridul Verma  \hspace{0.5cm}Rabi Shanker Guha   \hspace{0.5cm}Shikhar Sharma \\10404  \hspace{2.5cm}10415 \hspace{2.5cm}10551  \hspace{2.5cm}10682\\
	\\
	Professor : Dr. Sanjeev K Aggarwal\\Mentor : Ajay Kumar  }
\date{\today}

%\begin{}
%\end{}


\begin{document}
\large
\maketitle
\vspace{-1.5cm}
\tableofcontents
\newpage
\section{Project Description}
We will be developing a compiler for the source language Oberon.
\subsection{Language}
The implementation would be done in C using Lex and Yacc. The target language would be MIPS Assembly code.
\subsection{Implementation}
There are four different phases of a compiler(apart from the code optimization part) : 
\subsubsection{Lexical Analysis or Scanning}
This phase reads the source code and creates meaningful sequences called lexemes. Then each lexeme is used to produce a token of the form
\begin{center}
$<$token-name, attribute-value$>$
\end{center}
to pass it on for syntax analysis. Token-name is an abstract symbol used in syntax analysis while attribute-value points to an entry in symbol table for this token.
\subsubsection{Syntax Analysis or Parsing}
In this stage a syntax tree is constructed using the tokens obtained from lexical analyzer. In this tree, each internal node represents an operation and the children of the node represent the arguements of the operation. The subsequent phases use this structure to analyze the source program and generate the target program.
\subsubsection{Semantic Analysis}
This phase checks the source code for semantic consistency using the syntax tree and information in symbol table. One of the important part of semantic analysis is type checking.
\subsubsection{Intermediate Code Generation}
In the overall processs of translating source code into target program, one or more intermediate representations maybe generated.After syntax and semantic analysis of the source code, a low-level or machine-like intermediate code is generated. It should be easy to produce and easy to translate into the target machine.
\subsubsection{Code Generation}
In this phase, the intermediate representation generated in last step is mapped to target language. Since the target language is a machine code in our case, we will have to select registers or memory locations for each variable in the program. We then translate the intermediate instructions into a sequence of machine instructions that perform the same task.

\section{Basic Things to be Implemented}
\subsection {Identifiers}
Identifiers are combination of letters and digits such that the first character is always a letter.
\begin{center}{\it ID  :- [a-­zA-Z][a-­zA-Z0-­9]* }\end{center}
\subsection { Keywords }
Keywords are identidiers with a predefined meaning.Following is a list of some examples of keywords in Oberon.

\begin{multicols}{4}
\begin{enumerate}
\item ABS 
\item ASR 
\item ASSERT 
\item BOOLEAN 
\item CHAR
\item CHR 
\item COPY 
\item DEC 
\item EXCL 
\item FLOOR
\item FLT 
\item INC 
\item INCL 
\item INTEGER 
\item LEN
\item LSL 
\item LONG 
\item LONGREAL 
\item NEW 
\item ODD
\item ORD 
\item PACK 
\item REAL 
\item ROR 
\item SET
\item SHORT 
\item UNPK
\end{enumerate}
\end{multicols}

\subsection{Variables}
Variable is an identifier containing known or unknown values. During lexical analysis, variables have to be sorted out according to the types they belong to.

\subsection {Comments}
Comments are arbitrary character sequences inserted netween any two symbols.They do not affect the meaning of the program and are opened and closed by (* and *) respectively. {\bf Nested Comments} can also be implemented by writing comments inside other comments.{\bf Eg:} (*This is a (*nested *) comment *).

\subsection {Data Types}
Our Compiler will allow the following data types.

\subsubsection {Basic Data Types}

\begin{center}
  \begin{tabular}{| l | c | r | }
    \hline
    BOOLEAN & value is TRUE or FALSE & TRUE ${|}$ FALSE \\ \hline
    CHAR & Belongs to a certain character set & [.\textbackslash n]* \\ \hline
    INTEGER & integers & [-0-9][0-9]* \\ \hline
   REAL & real numbers & [0-9]+"."[0-9]*\\  \hline
  LONG REAL & real numbers with relatively higher number of digits& [0-9]+"."[0-9]*\\ 
    \hline
  \end{tabular}
\end{center}

\subsubsection{Array Data Type}
An array consists of fixed number of elements of same type. Our compiler will support arrays of upto three dimensions of the basic data types described above. Arrays are declared as -:
\begin{center}
{ARRAY $N_{0} N_{1} N_{2} ...... N_{k}$ OF T}
\end{center}
By means of lexical and syntax analysis we will make the following sense out of the above declaration : {\it An array of dimension $N_{0} by N_{1} by N_{2} by ...... by N_{k}$ of the type T}.

\subsubsection{Records Data Type}
Records also consist of fixed number of elements but they may be of different types.In the declaratiion of record we specify the type of each element (field) and an identifier to represent each field. As the element type can be anything, it can be record itself also and hence nested records also exist.

\subsubsection{Pointers}
Variables of a Pointer Type P is meant to have pointer values, pointing to a certain type T.
\begin{center}
PointerType = POINTER TO type.
\end{center}
\subsection{ Operators}
Following is the list of operators that would be implemented.

\begin{center}
  \begin{tabular}{| c | c | c | }
\hline
  \multirow{7}{*}{Relational Operators} & Equal & = \\
 & unequal & \# \\
 & Less& \textless \\
 & Less or Equal& \textless=\\
 & Greater or Equal& \textgreater=\\ 
 & Set Membership & IN \\
 & Type Test & IS \\
 & Relation &  \empty\\ \hline
 \multirow{6}{*}{Arithmetic Operators} & Sum & + \\
 & Difference & - \\
 &  Product & * \\
 & Quotient & /\  \\ 
 & Integer Quotient & DIV \\
 & Modulus & MOD \\ \hline
\multirow{4}{*}{Set Operators} & Union & + \\
 & Complement for single set & - \\
 &  Difference for more than one set & - \\
 & Intersubsection & *\\ 
 & Symmetric Set Difference & /\ \\ \hline
\multirow{3}{*}{Logical Operators} & Logical Disjunction & OR \\
 & Logical Conjunction & \& \\
 & Negation & $\sim$ \\ \hline
Assignment Operator & Assignment & := \\ \hline
  \end{tabular}
\end{center}

\subsection{ Loops}
Loops are for performing a task repititively.The following loops will be implemented : 
\subsubsection{repeat-until}
Statements are executed until a condition is satisfied.
\begin{center}
RepeatStatement = REPEAT StatementSequence UNTIL expression.
\end{center}
\subsubsection{for}
Statements are repeated iteratively, with three defined conditions,beginning, ending and the control variable condition.
\begin{center}
FOR v := beg TO end BY inc DO S END
\end{center}
here the control variable is v and the statements are S.
\subsubsection{while}
Statements in while loop are executed as long as the boolean guard is true.
\begin{center}
WhileStatement = WHILE expression DO StatementSequenceEND\\
\{ELSIF expression DO StatementSequence\} END
\end{center}
\subsection{Control Structures}
Control Structures are used to execute some statements under certain specified conditions only.The following will be implemented:
\subsubsection{if-else}
If-Else is used to execute the enclosed statements only when the boolean expression acting as guard is true.
\begin{center}
IfStatement = IF expression THEN StatementSequence \\
\{ELSIF expression THEN StatementSequence\} \\
\hspace{-1.5in} $[$ELSE StatementSequence$]$ \\
\hspace{-3in} END
\end{center}
\subsubsection{case (for char and integer data type only)}
In Case statements, the choice of which statement sequence will be executed is dependent on the value of a variable. In our implementation that variable is limited to only integer and char data type.
\begin{center}
CaseStatement = CASE expression OF case \{"$|$" case\} END\\
\hspace{-0.5in}case = ValueOfk : CorrespondingStatementSequence
\end{center}
\subsection{Basic string operations}
We will also be implementing some basic string operations such as : 
\begin{center}
\begin{tabular}{|c|c|}
\hline
Length & Calculating the length of the string \\ \hline
Concatenation & To concatenate two given strings \\ \hline
String Copy & To copy one string into other \\ \hline
Reverse & To reverse the characters in a given string \\ \hline
Compare & To compare two strings for equality \\ \hline
\end{tabular}
\end{center}

\subsection{Procedures with formal parameters}
Procedure declarations consist of procedure heading to specify the procedure identifier, the formal parameters and the result type(if there is any) and a procedure body that contains declarations and statements.Formal Parameters are identifiers to denote the actual parameters in a procedure declaration. Formal parameters are local to the procedure, i.e. their scope is the procedure declaration.

\section{Features to be implemented if time permits}
\begin{itemize}
\item Modules
\begin{itemize}
\item Module In
\item Module Out
\end{itemize}
\item Code Optimization
\end{itemize}
\section {References}
\begin{itemize}
\item The Programming Language Oberon, Revision 22.9.2011 by Niklaus Wirth
\item Compilers Principles, Tools and Techniques By Aho, Lam, Sethi and Ullman
\end{itemize}
\end{document}
 